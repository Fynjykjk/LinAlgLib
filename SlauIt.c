#include <stdio.h>
#include <stdlib.h>
#include <math.h>

//Метод простой итерации
int approximate(int N, double** A, double* b, double* x, double eps) 
{
    double err[N];  //Вектор ошибок для каждой переменной
    double x0[N];   //Вектор решения на предыдущей итерации
    double maxx;    //Максимальная ошибка на текущей итерации
    int k = 0;      //Счетчик итераций

    //Инициализация начального приближения нулями
    for (int i = 0; i < N; i++) {
        x0[i] = 0.0;
    }

    //Нормирование уравнений
    for (int i = 0; i < N; i++)
    {
        b[i] /= A[i][i];  //деление правой части
        for (int j = 0; j < N; j++)
        {
            if (i != j)
            {
                A[i][j] /= A[i][i];  //деление недиагональных элементов
            }
        }
        A[i][i] = 1.0;  //Диагональный элемент становится равным 1
    }

    //Основной итерационный процесс
    do
    {
        maxx = 0;  //Сбрасываем максимальную ошибку
        
        //Вычисление нового приближения
        for (int i = 0; i < N; i++)
        {
            x[i] = b[i];
            
            for (int j = 0; j < N; j++)
            {
                if (i != j)
                {
                    x[i] -= A[i][j] * x0[j];
                }
            }
        }
        
        //Вычисление ошибки итерации
        for (int i = 0; i < N; i++)
        {
            err[i] = fabs(x[i] - x0[i]);  //Абсолютная ошибка
            if (maxx < err[i])
            {
                maxx = err[i];
            }
        }
        
        //Проверка условия выхода (достижение требуемой точности)
        if (maxx < eps) break;
        
        //Подготовка к следующей итерации
        for (int i = 0; i < N; i++)
        {
            x0[i] = x[i];  //Текущее решение становится предыдущим
        }
        k++;  //Увеличивается счетчик итераций
        
    } while (k <= 300);  //Защита от бесконечного цикла (макс 300 итераций)
    
    return k;  //Возврат количествв итераций
}
