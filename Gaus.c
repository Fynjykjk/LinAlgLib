#include <stdio.h>
#include <stdlib.h>
#include <math.h>

//Размерность

void swap(double *a, double *b) 
{
    double temp = *a;
    *a = *b;
    *b = temp;
}

//Функция решения СЛАУ методом Гаусса
int Gaus(double** A, double* b, double* x, int m, int n) 
{
    int k; 
    double d; //Множитель для обнуления
    int flag = 0, flag1 = 0;  //Флаги для контроля особых случаев
    double maximal; //Максимальное число в строке
    double s1, s2 = 0;  //Вспомогательные переменные для вычислений
    int i0;         //Индекс строки с максимальным элементом

    //Приведение к ступенчатому виду матрицы
    for (int i = 0; i < (m < n ? m : n); i++) // Цикл по диагональным элементам
    {
        maximal = A[i][i]; 
        for (int j = i; j < m; j++) 
        {
            if (fabs(maximal) < fabs(A[j][i])) 
            {
                flag = 1;
                maximal = A[j][i];
                i0 = j;
            }
        }
        
        //Если найден больший элемент, меняем строки местами
        if (flag == 1) 
        {
            for (int u = 0; u < n; u++) 
            {
                swap(&A[i][u], &A[i0][u]);
            }
            swap(&b[i], &b[i0]);
            flag = 0;
        }
        
        //Обнуление элементов под главной диагональным элементом
        for (int j = i; j < m - 1; j++) 
        {
            d = A[j + 1][i] / A[i][i];  
            A[j + 1][i] = A[j + 1][i] - A[i][i] * d;  //Обнуление элемента
            b[j + 1] = b[j + 1] - b[i] * d;           //Корректировка свободного члена
            
            //Корректировка остальных элементов строки
            for (int u = i + 1; u < n; u++) 
            {
                A[j + 1][u] = A[j + 1][u] - A[i][u] * d;
            }
        }
    }

    //Проверка на особые случаи после приведения к ступенчатому виду
    if (A[m - 1][m - 1] == 0 && n > m) 
    {
        //Попытка найти ненулевой элемент в строке для перестановки
        for (int j = m; j < n; j++) 
        {
            if (A[m - 1][j] != 0) 
            {
                swap(&A[m - 1][m - 1], &A[m - 1][j]);
                flag = 1;
                break;
            }
        }
        
        if (flag == 0 && b[m - 1] == 0) 
        {
            return 2;  //Бесконечно много решений
        }
        if (flag == 0 && b[m - 1] != 0) 
        {
            return 0;  //Нет решений
        }
    }

    //Обратный ход (когда столбцов больше чем строк)
    if (A[m - 1][m - 1] != 0 && n > m) 
    {
        //Вычисление последнего неизвестного
        for (int j = m; j < n; j++) 
        {
            s2 += A[m - 1][j] * k;
            k += 1;
        }
        x[m - 1] = (b[m - 1] - s2) / A[m - 1][m - 1];
        
        //Вычисление остальных неизвестных
        for (int i = m - 2; i >= 0; i--) 
        {
            s1 = 0;
            s2 = 0;
            k = 0;
            for (int j = i + 1; j < m; j++) 
            {
                s1 += A[i][j] * x[j];
            }
            for (int j = m; j < n; j++) 
            {
                s2 += A[i][j] * k;
                k += 1;
            }
            x[i] = (b[i] - s1 - s2) / A[i][i];
        }
        return 1;  //Единственное решение
    } 
    else 
    {
        //Проверка на несовместность системы (если строк больше чем столбцов)
        if (m > n)
        {
            for (int i = m - 1; i > n - 1; i--)
            {
                if (b[i] != 0)
                {
                    flag1 = 1;
                }
            }
            if (flag1 == 1) return 0;  // Нет решений
        }
        
        //Обратный ход для m = n или m < n
        x[n - 1] = (b[n - 1] - s2) / A[n - 1][n - 1];
        for (int i = n - 2; i >= 0; i--) 
        {
            s1 = 0;
            for (int j = i + 1; j < n; j++) 
            {
                s1 += A[i][j] * x[j];
            }
            x[i] = (b[i] - s1) / A[i][i];
        }
        return 1;  //Единственное решение
    }
    printf("\n");
}

